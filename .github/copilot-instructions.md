<!-- Autogenerated by an assistant. Edit as needed. -->

# Copilot instructions for this repository

This file gives focused, actionable guidance to AI coding agents working on this NestJS backend template. Keep suggestions tightly tied to the codebase and avoid speculative changes.

- Project entry points

  - Server bootstrap: `src/main.ts` (CORS, session, Swagger, global pipes/filters/interceptors)
  - App module composition: `src/modules/app/app.module.ts` (imports: `PrismaModule`, `SseModule`, `AuthModule`, `UsersModule`, `RolesModule`, `PermissionsModule`, etc.)

- Build / run / debug

  - Dev run (hot reload): `npm run start:dev` (calls `nest start --watch`).
  - Production build: `npm run build` then `npm run start:prod` (runs `node dist/main`).
  - Docker-based development: `npm run docker:up` (wrapper for `docker/compose-up.sh` which starts MySQL and the app). The docker-compose file is `docker-compose.yml` and the app container runs `npm run start:dev` after installing deps and applying Prisma migrations.

- Tests and coverage

  - Unit tests: `npm test` (Jest). E2E: `npm run test:e2e` using `test/jest-e2e.json`.
  - Jest root config is `jest.config.js` and tests live in `src` (rootDir set to `src`). The project uses `ts-jest`.

- Database and Prisma

  - Prisma schema: `prisma/schema.prisma` and seed script `prisma/seed.ts` (seed command configured in `package.json`).
  - Typical Docker flow runs `npx prisma migrate deploy && npx prisma db seed && npx prisma generate` inside container; mirror this order when scripting locally.

- Conventions and patterns

  - Path aliases are used throughout (see `tsconfig.json` and `jest.config.js` mappings). Common aliases: `@modules/*`, `@configs/*`, `@common/*`, `@decorators/*`, etc. Honor these aliases when adding imports.
  - App-wide concerns are handled with Nest features: global pipes (validation), global filters (`common/filters/http-exception.filter.ts`), and interceptors (`common/interceptors/transform.interceptor.ts`). Use the existing patterns when adding cross-cutting behavior.
  - Interceptors system: Three specialized interceptors work together - `TransformInterceptor` (global, wraps all responses in `{ data: ... }`, handles BigInt/Decimal normalization), `SerializeInterceptor` (use with `@UseInterceptors` for DTO serialization), `PaginationInterceptor` (auto-generates pagination links with meta/data structure). Use `@SkipTransform()` decorator to bypass global wrapping.
  - Authentication stack: passport strategies under `src/modules/api/core/auth/*`. Tokens use cookies/sessions (see `src/main.ts` cookie & session setup and `common/adapters/cookie-io.adapter.ts`). When modifying auth flows, preserve cookie/session behavior and `SESSION_SECRET` usage.
  - Websockets use a custom adapter: `common/adapters/cookie-io.adapter.ts` — preserve adapter behavior when touching socket code.

- Where to change behavior safely

  - Add new API routes as modules under `src/modules/api/` with DTOs, entities, and controllers alongside existing patterns.
  - Shared resources: `src/modules/shared/prisma/` (singleton Prisma provider), `src/modules/shared/events/` (EventEmitter patterns). Prefer DI via module providers.

- Linting and formatting

  - ESLint + Prettier configured. Run `npm run lint` and `npm run format` before submitting PRs.

- Quick examples (do not invent files)

  - To add a new controller: create `src/modules/api/<feature>/<feature>.module.ts`, `<feature>.controller.ts`, `<feature>.service.ts` and add module to `src/modules/app/app.module.ts` imports.
  - To run Prisma locally: `npx prisma migrate dev` then `npm run prisma` scripts in `package.json`.

- Common edit examples

  - **Add new auth strategy**: Place under `src/modules/api/core/auth/strategies/`, extend passport strategy, register in `auth.module.ts`. Follow patterns in existing auth files.
  - **Add Prisma migration**: Run `npx prisma migrate dev --name descriptive_name` after editing `prisma/schema.prisma`. Docker users: restart container or run `npm run docker:prisma`.
  - **Add new API module**: Create `src/modules/api/<name>/` with module/controller/service/dto files. Import the module in `src/modules/app/app.module.ts`. Use existing modules like `health/` or `payment/` as templates.
  - **Modify global behavior**: Edit `src/main.ts` for app-wide middleware, `common/filters/http-exception.filter.ts` for error handling, `common/interceptors/transform.interceptor.ts` for response transformation.
  - **Use response interceptors**: Apply `@UseInterceptors(new SerializeInterceptor(YourDto))` for DTO serialization, `@UseInterceptors(PaginationInterceptor)` for paginated endpoints. The PaginationInterceptor requires your service method to return `{ items: T[], total: number }` format - it will transform this into `{ data: T[], meta: { total, page, limit, totalPages }, links: { first, last, next, previous } }`. Use `@SkipTransform()` when you need raw response without global `{ data: ... }` wrapper.

- Testing patterns

  - **Unit tests**: Place `.spec.ts` files next to source files. Use path aliases (`@modules/*`, `@common/*`) in imports. Mock Prisma with `jest.fn()` or use test containers.
  - **Test template**: Follow this pattern for services:
    ```typescript
    describe('FeatureService', () => {
      let service: FeatureService;
      beforeEach(async () => {
        const module = await Test.createTestingModule({
          providers: [
            FeatureService,
            { provide: PrismaService, useValue: mockPrisma },
          ],
        }).compile();
        service = module.get(FeatureService);
      });
      it('should be defined', () => expect(service).toBeDefined());
    });
    ```
  - **Coverage requirements**: Maintain 90% coverage (see `jest.config.js` thresholds). DTOs, enums, modules, and config files are excluded from coverage.
  - **E2E tests**: Use `test/jest-e2e.json` config. Follow `test/app.e2e-spec.ts` patterns for full request/response testing.

- Safety rules for AI edits
  - Do not change environment/secrets or `.env-example` content. If a migration is required, add migration files under `prisma/migrations/` and update `prisma/schema.prisma` only.
  - Avoid changing global error handling unless explicitly requested — those are centralized in `common/filters/http-exception.filter.ts` and `common/interceptors/transform.interceptor.ts`.
  - Preserve existing public API shapes unless given an explicit breaking-change task.

If anything in these instructions is unclear or you need additional specifics (e.g., preferred testing patterns or CI hooks), tell me which area to expand.
